WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.450
There are multiple strategies for ensuring the data processed and

00:00:03.450 --> 00:00:08.130
generated by an application ends up in an encrypted state on-disk.

00:00:08.130 --> 00:00:10.650
Let's look at a few common scenarios for

00:00:10.650 --> 00:00:14.925
persisting data in a Cloud environment and see how that data is encrypted.

00:00:14.925 --> 00:00:18.810
In each scenario, we will have some common themes.

00:00:18.810 --> 00:00:23.980
The key management service will be needed to store and manage encryption keys.

00:00:23.980 --> 00:00:27.500
Applications and infrastructure will be configured to use

00:00:27.500 --> 00:00:31.865
a specific encryption key that will be used to encrypt the data.

00:00:31.865 --> 00:00:36.340
AWS provides a key management service called KMS.

00:00:36.340 --> 00:00:40.174
KMS is tightly integrated with the AWS services

00:00:40.174 --> 00:00:44.315
and the AWS SDKs that a developer would be using.

00:00:44.315 --> 00:00:49.535
Choose to encrypt the data with the application prior to persisting or writing.

00:00:49.535 --> 00:00:53.270
We will loosely refer to this as Client-side Encryption.

00:00:53.270 --> 00:00:58.910
The AWS services can also be configured to handle the underlying encryption activities.

00:00:58.910 --> 00:01:02.570
We can refer to this broadly as a server-side encryption.

00:01:02.570 --> 00:01:06.305
Let's look at how encryption works when writing data to disk.

00:01:06.305 --> 00:01:09.530
An application may write data to a file on disk that

00:01:09.530 --> 00:01:12.935
is in a mounted directory on the local operating system.

00:01:12.935 --> 00:01:18.575
The underlying volume may be mounted from an EBS volume or an EFS share.

00:01:18.575 --> 00:01:21.800
The application can obtain a data encryption key from

00:01:21.800 --> 00:01:25.775
KMS and use it to encrypt the data prior to writing to disk.

00:01:25.775 --> 00:01:28.550
Once a data encryption key is obtained,

00:01:28.550 --> 00:01:32.855
developers can choose to use language data of encryption libraries.

00:01:32.855 --> 00:01:37.895
They can also leverage the AWS SDK to go through the encryption process.

00:01:37.895 --> 00:01:41.330
The AWS SDK helps by encapsulating

00:01:41.330 --> 00:01:44.930
many of the steps required to encrypt and store the data.

00:01:44.930 --> 00:01:46.865
On the infrastructure side,

00:01:46.865 --> 00:01:51.410
we need to ensure that disk volumes are configured to use KMS encryption so that

00:01:51.410 --> 00:01:53.900
the entire disk remains encrypted regardless of

00:01:53.900 --> 00:01:57.875
the fact that the application chooses to encrypt or not,

00:01:57.875 --> 00:02:02.915
the EC2 service can obtain a data encryption key from KMS.

00:02:02.915 --> 00:02:08.630
The encryption key is based on a master key that the EBS volume is associated with.

00:02:08.630 --> 00:02:12.260
The data encryption key is then used by the hypervisor to ensure

00:02:12.260 --> 00:02:16.835
that all IO operations result in encrypted data on-disk.

00:02:16.835 --> 00:02:19.850
Write operations will use the key to encrypt

00:02:19.850 --> 00:02:23.165
and read operations will use the key to decrypt.

00:02:23.165 --> 00:02:26.060
The hypervisor will make the data available and

00:02:26.060 --> 00:02:29.065
decrypt it to the instance operating system.

00:02:29.065 --> 00:02:32.000
We'll also be writing data to a database table.

00:02:32.000 --> 00:02:35.795
The same concept we used to write data to disk volumes applies here.

00:02:35.795 --> 00:02:38.600
The application should encrypt sensitive data prior

00:02:38.600 --> 00:02:41.270
to storing the record value in the database.

00:02:41.270 --> 00:02:43.280
Again, on the infrastructure side,

00:02:43.280 --> 00:02:48.530
we need to ensure that encryption is enabled when provisioning the databases in AWS.

00:02:48.530 --> 00:02:50.330
When encryption is enabled,

00:02:50.330 --> 00:02:54.110
services such as DynamoDB and RDS leverage

00:02:54.110 --> 00:02:58.930
KMS master keys to ensure that the data is encrypted at rest.

00:02:58.930 --> 00:03:05.150
Applications will be using Cloud storage such as S3 to store data and file objects.

00:03:05.150 --> 00:03:08.690
When an application is handling highly sensitive data,

00:03:08.690 --> 00:03:14.850
the code should be designed to encrypt the data object prior to putting it in S3.

00:03:14.950 --> 00:03:19.980
Because we encrypt the object prior to making the call to write the object,

00:03:19.980 --> 00:03:23.215
we refer to this as Client-side encryption.

00:03:23.215 --> 00:03:26.030
In the case of the S3 service,

00:03:26.030 --> 00:03:28.820
the application can also set parameters on

00:03:28.820 --> 00:03:32.495
the put object call for server-side encryption.

00:03:32.495 --> 00:03:38.915
This tells the S3 service to handle the encryption for the object that is being stored.

00:03:38.915 --> 00:03:44.000
We can also configure S3 buckets with default server-side encryption.

00:03:44.000 --> 00:03:47.225
With default server-side encryption enabled,

00:03:47.225 --> 00:03:53.030
the S3 service takes care of the encryption of the data on the underlying infrastructure.

00:03:53.030 --> 00:03:54.695
As a best practice,

00:03:54.695 --> 00:03:59.270
we want to ensure that S3 server side encryption is enabled by default for

00:03:59.270 --> 00:04:05.335
all buckets so that the encryption logic can be encapsulated from the application code.

00:04:05.335 --> 00:04:07.979
So client-side or server-side,

00:04:07.979 --> 00:04:09.820
which one should be used?

00:04:09.820 --> 00:04:13.880
Let's look at the pros and cons of client-side encryption.

00:04:13.880 --> 00:04:18.200
The data will be encrypted and protected regardless of the fact that

00:04:18.200 --> 00:04:22.735
SERVER-SIDE Encryption is being used on the infrastructure side or not.

00:04:22.735 --> 00:04:24.875
Also, the Cloud provider,

00:04:24.875 --> 00:04:27.770
that is AWS or anyone with access to

00:04:27.770 --> 00:04:32.495
the underlying disk volumes will only see ciphered or encrypted data.

00:04:32.495 --> 00:04:36.110
The data is effectively useless to them unless of course,

00:04:36.110 --> 00:04:39.835
they have permissions or access to the encryption keys.

00:04:39.835 --> 00:04:42.190
What about the drawbacks?

00:04:42.190 --> 00:04:46.070
The code will have additional complexity of using SDKs

00:04:46.070 --> 00:04:50.495
and libraries required to perform cryptographic functions.

00:04:50.495 --> 00:04:52.670
There's always the potential of

00:04:52.670 --> 00:04:57.635
this additional functionality being inadvertently omitted from the code.

00:04:57.635 --> 00:05:00.170
What about server-side encryption?

00:05:00.170 --> 00:05:01.790
For most use cases,

00:05:01.790 --> 00:05:03.620
server-side encryption can be completely

00:05:03.620 --> 00:05:07.265
transparent to the developer or application code.

00:05:07.265 --> 00:05:10.534
Also, from an implementation perspective,

00:05:10.534 --> 00:05:12.560
it is simpler and easier to use.

00:05:12.560 --> 00:05:17.705
Oftentimes, it's simply a flag that's enabled when provisioning infrastructure.

00:05:17.705 --> 00:05:20.630
Now, anyone with elevated permissions to

00:05:20.630 --> 00:05:23.810
the Cloud infrastructure service that's being used,

00:05:23.810 --> 00:05:28.470
such as admin, users may be able to see the plaint text data.

00:05:28.470 --> 00:05:31.760
This can be solved by ensuring that role and

00:05:31.760 --> 00:05:37.250
responsibility segmentation aligns to access permissions on encryption keys.

00:05:37.250 --> 00:05:42.140
As a best practice, it is highly advisable to leverage server-side encryption as

00:05:42.140 --> 00:05:47.405
a default deployment pattern for any AWS services being used to store data.

00:05:47.405 --> 00:05:51.950
The decision to use client-side encryption in your applications may be made on

00:05:51.950 --> 00:05:57.600
a case by case basis for sensitive data or to meet compliance requirements.

